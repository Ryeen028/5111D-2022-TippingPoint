{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\n#pragma endregion VEXcode Generated Robot Configuration\n\n// ----------------------------------------------------------------------------\n//                                                                            \n//    Project:  Forkbot                                             \n//    Author: Ryan Richter (builders Tyler Michaels, Kevin Clark, Cavan Hicks)\n//    Created:\n//    Configuration:        \n//                                                                            \n// ----------------------------------------------------------------------------\n\n/*\nCONTROLS:\nLeft Stick    :     Move\nX             :     Toggle Reverse\nY             :     Protect Lifts\nB             :     Boost\nA             :     180\nL1            :     Back Lift Up\nL2            :     Back Lift Down\nR1            :     Front Lift Up\nR2            :     Front Lift Down\n*/\n\n// Include the V5 Library\n#include \"vex.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// Begin project code\n// DEVICE CONFIG ----------------------------------\ncontroller ctrl;\n\ncontroller::button in_a180 = ctrl.ButtonA;\ncontroller::button in_boost = ctrl.ButtonB;\ncontroller::button in_reverseDirection = ctrl.ButtonX;\ncontroller::button in_protectLift = ctrl.ButtonY;\ncontroller::button in_lift1UP = ctrl.ButtonL1;\ncontroller::button in_lift1DOWN = ctrl.ButtonL2;\ncontroller::button in_lift2UP = ctrl.ButtonR1;\ncontroller::button in_lift2DOWN = ctrl.ButtonR2;\n\n// DRIVE DEVICES\n// L/R = Left/Right and 1/2 = Front/Back\nmotor driveL1 = motor(PORT1, ratio18_1, true);\nmotor driveL2 = motor(PORT5, ratio18_1, true);\nmotor driveR1 = motor(PORT17, ratio18_1, true);\nmotor driveR2 = motor(PORT18, ratio18_1, true);\nmotor_group driveL = motor_group(driveL1, driveL2);\nmotor_group driveR = motor_group(driveR1, driveR2);\n\n// LIFT DEVICES\nmotor liftL1 = motor(PORT16, ratio36_1, true);\nmotor liftR1 = motor(PORT11, ratio36_1, false);\nmotor liftL2 = motor(PORT15, ratio36_1, false);\nmotor liftR2 = motor(PORT12, ratio36_1, true);\n\nmotor_group lift1 = motor_group(liftL1, liftR1);\nmotor_group lift2 = motor_group(liftL2, liftR2);\n\n// ----------------------------------------------------------------------------------------------\n// DEFAULT VALUES\nconst float dHDF = 0.5;\nconst float dVelo = 100 * dHDF;\nconst int dLiftPower = 30;\nconst int dRingSafetyThreshold = 0;\n\n// DEFAULT CONSTANT MULTIPLIERS\nconst float cmDistance = 360 / 12.56;\nconst float cmLift = 1;\nconst float cmSpin1 = 1;\nconst float cmSpin2 = 1;\n\n// GLOBAL VARIABLES\nint driveDirection = 1;\n\n// AUTON SELECT STUFF\nint currentlySelected = 0;\nbool isSelectingAuton = true;\n\nvoid doNothing() { // replaces callback for touching the brain screen after preauton\n  wait(1, msec);\n}\n\n\n// ----------------------------------------------------------------------------------------------\n// FUNCTION DECLERATIONS\n// GUI STUFF\nvoid ctrlPreAutonGUI() {\n  ctrl.Screen.clearScreen();\n  wait(10, msec);\n  ctrl.Screen.setCursor(1, 1);\n  ctrl.Screen.print(\"Currently Selecting %d: \", currentlySelected);\n  ctrl.Screen.setCursor(1,2);\n  switch ( currentlySelected ) {\n    case 0:\n    ctrl.Screen.print(\"noAuto\");\n    break;\n    case 1:\n    ctrl.Screen.print(\"RABS\");\n    break;\n    case 2:\n    ctrl.Screen.print(\"RABM\");\n    break;\n    case 3:\n    ctrl.Screen.print(\"RAWP\");\n    break;\n    case 4:\n    ctrl.Screen.print(\"LABS\");\n    break;\n    case 5:\n    ctrl.Screen.print(\"LABM\");\n    break;\n    case 6:\n    ctrl.Screen.print(\"LAWP\");\n    break;  \n  }\n  ctrl.Screen.setCursor(2, 1);\n  if ( isSelectingAuton ) {\n    ctrl.Screen.print(\"Not Confirmed\");\n  }\n  else {\n    ctrl.Screen.print(\"Confirmed\");\n  }\n}\n\nvoid ctrlAutonGUI() {\n  ctrl.Screen.clearScreen();\n  wait(10, msec);\n  ctrl.Screen.print(\"Auton running\");\n}\n\nvoid ctrlUserGUI() {\n  ctrl.Screen.clearScreen();\n  wait(10, msec);\n  if ( driveDirection > 0 ) {\n    ctrl.Screen.print(\"Direction = Forwards\");\n  }  \n  else {\n    ctrl.Screen.print(\"Direction = Reverse\");\n  }\n  ctrl.Screen.clearScreen();\n  ctrl.Screen.setCursor(2, 1);\n  ctrl.Screen.print(\"Lift1.position = %d\", lift1.position(degrees));\n  ctrl.Screen.setCursor(2, 2);\n  ctrl.Screen.print(\" | isSafeFromRings = %s\", lift1.position(degrees) >= dRingSafetyThreshold);\n  ctrl.Screen.setCursor(3, 1);\n  ctrl.Screen.print(\"Lift2.position = %d\", lift2.position(degrees));\n  ctrl.Screen.setCursor(3, 2);\n  ctrl.Screen.print(\" | isSafeFromRings = %s\", lift2.position(degrees) >= dRingSafetyThreshold);\n  ctrl.Screen.setCursor(4, 1);\n  ctrl.Screen.print(\"Boost = %s\", in_boost.pressing());\n  ctrl.Screen.setCursor(1, 1);\n\n}\n\nvoid brainPreAutonGUI() {\n  Brain.Screen.clearScreen();\n  Brain.Screen.setFillColor(black);\n  wait(10, msec);\n  Brain.Screen.printAt(10, 40, \"Previous\");\n  Brain.Screen.printAt(120, 40, \"Next\");\n  Brain.Screen.printAt(380, 40, \"Confirm\");\n  Brain.Screen.printAt(230, 60, \"0: NA\");\n  Brain.Screen.printAt(230, 80, \"1: RABS\");\n  Brain.Screen.printAt(230, 100, \"2: RABM\");\n  Brain.Screen.printAt(230, 120, \"3: RAWP\");\n  Brain.Screen.printAt(230, 140, \"4: LABS\");\n  Brain.Screen.printAt(230, 160, \"5: LABM\");\n  Brain.Screen.printAt(230, 180, \"6: LAWP\");\n  Brain.Screen.printAt(10, 200, \"Selected: %d\", currentlySelected);\n\n  Brain.Screen.setFillColor(blue);\n  Brain.Screen.drawRectangle(10, 50, 100, 100);\n  Brain.Screen.drawRectangle(120, 50, 100, 100);\n\n  if ( !isSelectingAuton ) { \n    Brain.Screen.setFillColor(green);\n    Brain.Screen.drawRectangle(370, 50, 100, 100);\n  }\n  else {\n    Brain.Screen.setFillColor(red);\n    Brain.Screen.drawRectangle(370, 50, 100, 100);\n  }\n  Brain.Screen.setFillColor(black);\n}\n\nvoid brainAutonGUI() {\n  Brain.Screen.clearScreen();\n  wait(10, msec);\n  Brain.Screen.print(\"auton running\");\n}\n\nvoid brainUserGUI() {\n  // Red/Green depending on if the lifts are safe from rings\n  Brain.Screen.clearScreen();\n  if ( lift1.position(degrees) >= dRingSafetyThreshold ) {\n    Brain.Screen.setFillColor(green);\n  }\n  else {\n    Brain.Screen.setFillColor(red);\n  }\n  Brain.Screen.drawRectangle(1, 1, 1, 1); // lift1\n\n  if ( lift2.position(degrees) >= dRingSafetyThreshold ) {\n    Brain.Screen.setFillColor(green);\n  }\n  else {\n    Brain.Screen.setFillColor(red);\n  }\n  Brain.Screen.drawRectangle(1, 1, 1, 1); // lift2\n}\n\nvoid updatePreAutonGUI() {\n  brainPreAutonGUI();\n  ctrlPreAutonGUI();\n}\n\nvoid updateAutonGUI() {\n  brainPreAutonGUI();\n  ctrlPreAutonGUI();\n}\n\nvoid updateUserGUI() {\n  brainUserGUI();\n  ctrlUserGUI();\n}\n\n// ----------------------------------------------------------------------------------------------\n// PREAUTON FUNCTIONS HERE\nvoid selectAuton() {\n  int x = Brain.Screen.xPosition();\n  int y = Brain.Screen.yPosition();\n  if ( y >= 40 && y <= 140 ) {\n    if ( x >= 10 && x <= 110 ) {\n      currentlySelected--;\n    }\n    if ( x >= 120 && x <= 220) {\n      currentlySelected++;\n    }\n    if ( currentlySelected > 6) {\n      currentlySelected = 0;\n    }\n    if ( currentlySelected < 0 ) {\n      currentlySelected = 6;\n    }\n    if ( x >= 370 && x <= 470 ) {\n      isSelectingAuton = !isSelectingAuton;\n    }\n  }\n  wait(10, msec);\n  Brain.Screen.setFillColor(black);\n  updatePreAutonGUI();\n}\n\n// ----------------------------------------------------------------------------------------------\n// AUTONOMOUS FUNCTIONS\nvoid aMove(float dist, int velo=dVelo, bool wait_to_cont=true) {\n  // distance input is inches\n  float theta = dist * cmDistance;\n  driveL.spinFor(theta, rotationUnits::deg, velo, velocityUnits::pct, false);\n  driveR.spinFor(theta, rotationUnits::deg, velo, velocityUnits::pct, wait_to_cont);\n}\n\nvoid aSpin1(int rot, int velo=dVelo, int direction=0, bool wait_to_cont=true) {\n  // 0: counterclockwise, 1: clockwise\n  // spin around center of bot\n  // rot is rotation in degrees (of the bot)\n  if ( direction == 1 ) {\n    direction = -1;\n  }\n  float theta = rot * cmSpin1 * direction;\n  driveL.spinFor(theta * -1, rotationUnits::deg, velo, velocityUnits::pct, false );\n  driveR.spinFor(theta, rotationUnits::deg, velo, velocityUnits::pct, wait_to_cont);\n}\n\nvoid aSpin2(int rot, int side, int velo=dVelo, bool wait_to_cont=true) {\n  // 0: left, 1: right\n  float theta = rot * cmSpin2;\n  if ( side == 0 ) {\n    // this means that the left drive will spin and right will hold\n    driveL.spinFor(theta, rotationUnits::deg, velo, velocityUnits::pct, wait_to_cont);\n  }\n  else {\n    // this means that the right drive will spin and left will hold\n    driveR.spinFor(theta, rotationUnits::deg, velo, velocityUnits::pct, wait_to_cont);\n  }\n}\n\nvoid aLift(int rot, int side, int liftPower=dLiftPower, bool wait_to_cont=true) {\n  // side: 0=front, 1=back\n  float theta = rot * cmLift;\n  if ( side == 0 ) {\n    lift1.spinFor(theta, rotationUnits::deg, liftPower, velocityUnits::pct, wait_to_cont);\n  }\n  else {\n    lift2.spinFor(theta, rotationUnits::deg, liftPower, velocityUnits::pct, wait_to_cont);\n  }\n}\n\n// AUTONOMOUS MODES HERE -----------------------------------------------\nvoid noAuto() {\n  Brain.Screen.clearScreen();\n  Brain.Screen.setFillColor(red);\n  Brain.Screen.print(\"noAuto\");\n  wait(1, seconds);\n}\n\nvoid RABS() {\n  Brain.Screen.clearScreen();\n  Brain.Screen.setFillColor(green);\n  Brain.Screen.print(\"RABS\");\n  wait(1, seconds);\n}\n\nvoid RABM() {\n  Brain.Screen.clearScreen();\n  Brain.Screen.setFillColor(blue);\n  Brain.Screen.print(\"RABM\");\n  wait(1, seconds);\n}\n\nvoid RAWP() {\n  Brain.Screen.clearScreen();\n  Brain.Screen.setFillColor(yellow);\n  Brain.Screen.print(\"RAWP\");\n  wait(1, seconds);\n}\n\nvoid LABS() {\n  Brain.Screen.clearScreen();\n  Brain.Screen.setFillColor(purple);\n  Brain.Screen.print(\"LABS\");\n  wait(1, seconds);\n}\n\nvoid LABM() {\n  Brain.Screen.clearScreen();\n  Brain.Screen.setFillColor(orange);\n  Brain.Screen.print(\"LABM\");\n  wait(1, seconds);\n}\n\nvoid LAWP() {\n  Brain.Screen.clearScreen();\n  Brain.Screen.setFillColor(cyan);\n  Brain.Screen.print(\"LAWP\");\n  wait(1, seconds);\n}\n\n// ----------------------------------------------------------------------------------------------\n// USERCONTROL FUNCTIONS\nvoid reverseDirection() {\n  driveDirection *= -1;\n}\n\nvoid a180() {\n  aSpin1(180, 100, false);\n}\n\nvoid ringSafe() {\n  wait(1, msec);\n}\n\nvoid storeGoal() {\n  wait(1, msec);\n}\n\nvoid move() {\n  int x = ctrl.Axis4.position();\n  int y = ctrl.Axis3.position() * driveDirection;\n  driveL.spin(directionType::fwd, (x + y) * dHDF, velocityUnits::pct);\n  driveR.spin(directionType::fwd, (x - y) * dHDF, velocityUnits::pct);\n}\n\nvoid boost() {\n  float x = ctrl.Axis4.position();\n  driveL.spin(directionType::fwd, (100 + x) * driveDirection, velocityUnits::pct);\n  driveR.spin(directionType::fwd, (100 - x) * driveDirection, velocityUnits::pct);\n}\n\nvoid lift(int liftPower=dLiftPower) {\n  int lift1Direction = in_lift1UP.pressing() - in_lift1DOWN.pressing();\n  lift1.spin(directionType::fwd, liftPower * lift1Direction, velocityUnits::pct);\n  int lift2Direction = in_lift2UP.pressing() - in_lift1DOWN.pressing();\n  lift2.spin(directionType::fwd, liftPower * lift2Direction, velocityUnits::pct);\n\n  // if ( lift1UP.pressing() ) {\n  //   lift1.spin(directionType::fwd, liftPower, velocityUnits::pct);\n  // }\n  // else if ( lift1DOWN.pressing() ) {\n  //   lift1.spin(directionType::rev, liftPower, velocityUnits::pct);\n  // }\n  // else {\n  //   lift1.stop();\n  // }\n  // if ( lift2UP.pressing() ) {\n  //   lift2.spin(directionType::fwd, liftPower, velocityUnits::pct);\n  // }\n  // else if ( lift2DOWN.pressing() ) {\n  //   lift2.spin(directionType::rev, liftPower, velocityUnits::pct);\n  // }\n  // else {\n  //   lift2.stop();\n  // }\n}\n\n// ----------------------------------------------------------------------------------------------\n// STRUCTURE FUNCTIONS\nvoid preAutonomous(void) {\n  // actions to do when the program starts\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"pre auton code\");\n  wait(1, seconds);\n\n  Brain.Screen.pressed(selectAuton);\n  \n  lift1.setStopping(hold);\n  lift2.setStopping(hold);\n  driveL.setStopping(hold);\n  driveR.setStopping(hold);\n}\n\nvoid autonomous(void) {\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"autonomous code running\");\n  ctrl.Screen.print(\"autonomous code running\");\n  Brain.Screen.pressed(doNothing);\n  // place automonous code here\n  if ( !isSelectingAuton ) {\n    switch (currentlySelected) {\n      case 0:\n      noAuto();\n      break;\n      case 1:\n      RABS();\n      break;\n      case 2:\n      RABM();\n      break;\n      case 3:\n      RAWP();\n      break;\n      case 4:\n      LABS();\n      break;\n      case 5:\n      LABM();\n      break;\n      case 6:\n      LAWP();\n      break;\n      default:\n      noAuto();\n    }\n  }\n  else {\n    noAuto();\n  }\n\n}\n\n\nvoid userControl(void) {\n  Brain.Screen.clearScreen();\n  // place driver control in this while loop\n  in_reverseDirection.pressed(reverseDirection);\n  in_a180.pressed(a180);\n  while (true) {\n    wait(20, msec);\n    updateUserGUI();\n    if ( !in_boost.pressing() ) {\n      move();\n    }\n    else {\n      boost();\n    }\n    lift();\n  }\n}\n\nint main() {\n  // create competition instance\n  competition Competition;\n\n  // Set up callbacks for autonomous and driver control periods.\n  Competition.autonomous(autonomous);\n  Competition.drivercontrol(userControl);\n\n  // Run the pre-autonomous function.\n  preAutonomous();\n\n  // Prevent main from exiting with an infinite loop.\n  while (true) {\n    wait(100, msec);\n  }\n}","textLanguage":"cpp","rconfig":[],"slot":0,"platform":"V5","sdkVersion":"20211013.15.00.00","appVersion":"2.2.1","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}